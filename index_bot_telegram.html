<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Viewer</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #1c1c1e);
            --text-color: var(--tg-theme-text-color, #ffffff);
            --btn-color: var(--tg-theme-button-color, #3390ec);
            --btn-text: var(--tg-theme-button-text-color, #ffffff);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #2c2c2e);
        }
        body { margin: 0; background-color: var(--bg-color); color: var(--text-color); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        
        /* 3D Canvas Container */
        #canvas-container { 
            position: relative; 
            flex-grow: 1; 
            width: 100%; 
            background: radial-gradient(circle, #3a3a3c 0%, #1c1c1e 100%); /* –ì–∞—Ä–Ω–∏–π –≥—Ä–∞–¥—ñ—î–Ω—Ç –∑–∞–º—ñ—Å—Ç—å —á–æ—Ä–Ω–æ–≥–æ */
            overflow: hidden;
        }
        #viewer { width: 100%; height: 100%; outline: none; }
        
        /* Placeholder Text (—â–æ–± –Ω–µ –±—É–ª–æ –ø—É—Å—Ç–æ) */
        #placeholder {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #888; pointer-events: none;
        }
        #placeholder svg { width: 48px; height: 48px; margin-bottom: 10px; opacity: 0.5; }

        /* Controls Panel */
        .controls { 
            padding: 20px; 
            background: var(--bg-color); 
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
            border-top-left-radius: 16px; border-top-right-radius: 16px; 
            z-index: 10;
        }

        /* Stats Grid */
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; font-size: 14px; }
        .stat-item { background: var(--secondary-bg); padding: 10px; border-radius: 8px; }
        .stat-label { font-size: 11px; opacity: 0.7; display: block; margin-bottom: 2px; }
        .stat-val { font-weight: bold; font-size: 16px; }

        /* Buttons */
        input[type="file"] { display: none; }
        .btn { 
            display: flex; align-items: center; justify-content: center;
            width: 100%; padding: 14px; border: none; border-radius: 12px; 
            font-size: 16px; font-weight: 600; cursor: pointer; transition: 0.2s;
            text-decoration: none; box-sizing: border-box;
        }
        .btn-upload { background-color: var(--secondary-bg); color: var(--btn-color); border: 2px dashed var(--btn-color); }
        .btn-primary { background-color: var(--btn-color); color: var(--btn-text); margin-top: 10px; }
        .btn:active { transform: scale(0.98); opacity: 0.8; }

    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="placeholder">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 9l-8-5-8 5v10l8 5 8-5V9zm-8 12.5L5 17.75V11l7 4.5 7-4.5v6.75L12 21.5z"/></svg>
            <div>–ú–æ–¥–µ–ª—å –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ</div>
        </div>
        <div id="viewer"></div>
    </div>

    <div class="controls">
        <label for="file-upload" class="btn btn-upload">üìÇ –û–±—Ä–∞—Ç–∏ STL –∞–±–æ OBJ</label>
        <input type="file" id="file-upload" accept=".stl, .obj">

        <div class="stats-grid" id="stats-panel" style="display:none; margin-top:15px;">
            <div class="stat-item"><span class="stat-label">–û–±'—î–º</span><span class="stat-val" id="vol">0</span> —Å–º¬≥</div>
            <div class="stat-item"><span class="stat-label">–í–∞–≥–∞ (PLA)</span><span class="stat-val" id="weight">0</span> –≥</div>
            <div class="stat-item" style="grid-column: span 2; background: rgba(51, 144, 236, 0.15); color: var(--btn-color);">
                <span class="stat-label">–û—Ä—ñ—î–Ω—Ç–æ–≤–Ω–∞ —Ü—ñ–Ω–∞</span><span class="stat-val" id="price">0</span> –≥—Ä–Ω
            </div>
        </div>

        <button id="order-btn" class="btn btn-primary" style="display:none;" onclick="sendOrder()">‚úÖ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';
        import { STLLoader } from 'https://unpkg.com/three@0.126.0/examples/jsm/loaders/STLLoader.js';
        import { OBJLoader } from 'https://unpkg.com/three@0.126.0/examples/jsm/loaders/OBJLoader.js';

        const tg = window.Telegram.WebApp;
        tg.expand(); 

        let scene, camera, renderer, mesh, controls;
        let orderData = null;

        init();

        function init() {
            const container = document.getElementById('viewer');
            
            // Scene
            scene = new THREE.Scene();
            // grid helper for better orientation
            const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x555555);
            scene.add(gridHelper);

            // Camera
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 2.0;

            animate();
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- FILE HANDLING ---
        document.getElementById('file-upload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // UI Updates
            document.getElementById('placeholder').style.display = 'none';
            controls.autoRotate = false;
            
            const reader = new FileReader();
            const extension = file.name.split('.').pop().toLowerCase();

            reader.onload = function(event) {
                if (mesh) scene.remove(mesh); // Clear old model

                const contents = event.target.result;

                try {
                    if (extension === 'stl') {
                        loadSTL(contents);
                    } else if (extension === 'obj') {
                        loadOBJ(contents);
                    } else {
                        alert("–ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å —Ñ–∞–π–ª .stl –∞–±–æ .obj");
                    }
                } catch (err) {
                    alert("–ü–æ–º–∏–ª–∫–∞ —Ñ–∞–π–ª—É: " + err);
                }
            };

            if (extension === 'stl') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file); // OBJ is text-based
            }
        });

        function loadSTL(data) {
            const loader = new STLLoader();
            const geometry = loader.parse(data);
            createMesh(geometry);
        }

        function loadOBJ(data) {
            const loader = new OBJLoader();
            const object = loader.parse(data);
            
            // OBJ loads as a Group, we need to extract geometry or merge it
            let geometry = null;
            object.traverse(function (child) {
                if (child.isMesh) {
                    geometry = child.geometry; // Take the first mesh found
                    // Note: complex OBJs might need merging, but simple ones work this way
                }
            });

            if (geometry) {
                createMesh(geometry);
            } else {
                alert("–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≥–µ–æ–º–µ—Ç—Ä—ñ—ó –≤ OBJ");
            }
        }

        function createMesh(geometry) {
            // Material styling
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x3390ec, 
                specular: 0x111111, 
                shininess: 200,
                flatShading: true
            });

            // Geometry fixes
            geometry.computeVertexNormals();
            geometry.center(); // Center the model

            mesh = new THREE.Mesh(geometry, material);
            
            // Auto-Scaling logic (Fit to screen)
            geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Move camera back based on object size
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
            cameraZ *= 2.5; // Zoom out factor
            
            camera.position.set(cameraZ, cameraZ, cameraZ);
            camera.lookAt(0,0,0);
            
            mesh.rotation.x = -Math.PI / 2; // Usually STL/OBJ are rotated
            scene.add(mesh);

            calculateStats(geometry);
        }

        function calculateStats(geometry) {
            let vol = 0;
            
            // Calculate Volume (Signed Triangle Area method)
            if (geometry.index) {
                // Indexed geometry
                 // Simplified calculation for buffer geometry not implemented here for brevity
                 // falling back to basic attribute check
            }
            
            const pos = geometry.attributes.position;
            const p1 = new THREE.Vector3(), p2 = new THREE.Vector3(), p3 = new THREE.Vector3();
            for (let i = 0; i < pos.count; i += 3) {
                p1.fromBufferAttribute(pos, i);
                p2.fromBufferAttribute(pos, i + 1);
                p3.fromBufferAttribute(pos, i + 2);
                vol += p1.dot(p2.cross(p3)) / 6.0;
            }
            
            vol = Math.abs(vol) / 1000; // mm3 -> cm3
            if (isNaN(vol) || vol < 0.01) vol = 0.01; // Fallback

            const weight = vol * 1.24; // PLA
            let price = weight * 3.5; 
            if (price < 50) price = 50;

            // Update UI
            document.getElementById('vol').innerText = vol.toFixed(2);
            document.getElementById('weight').innerText = weight.toFixed(1);
            document.getElementById('price').innerText = Math.round(price);
            
            document.getElementById('stats-panel').style.display = 'grid';
            document.getElementById('order-btn').style.display = 'flex';

            orderData = { vol: vol.toFixed(2), weight: weight.toFixed(1), price: Math.round(price) };
        }

        window.sendOrder = function() {
            if (orderData) tg.sendData(JSON.stringify(orderData));
        };
    </script>
</body>
</html>
